<!DOCTYPE html>
<html lang="en">

<head>
	<title>Cardboard Example</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			margin: 0px;
			overflow: hidden;
		}

		#example {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
		}
	</style>
</head>

<body>
	<div id="example"></div>

	<script src="js/third-party/threejs/three.js"></script>
	<script src="js/third-party/threejs/StereoEffect.js"></script>
	<script src="js/third-party/threejs/DeviceOrientationControls.js"></script>
	<script src="js/third-party/threejs/OrbitControls.js"></script>

<script>
	var camera, scene, renderer;
	var effect, controls;
	var element, container, texture;
	var levels = ["back", "down", "Kent", "Kent-", "next", "up"];

	var addto = 0;
	var ws = new WebSocket("ws://131.123.245.200:8001");

	var objects = {};

	var clock = new THREE.Clock();

	init();
	animate();

	function init() {
		renderer = new THREE.WebGLRenderer();
		element = renderer.domElement;
		container = document.getElementById('example');
		container.appendChild(element);

		effect = new THREE.StereoEffect(renderer);

		scene = new THREE.Scene();

		camera = new THREE.PerspectiveCamera(90, 1, 0.001, 700);
		camera.position.set(0, 100, 0);
		scene.add(camera);

		controls = new THREE.OrbitControls(camera, element);
		controls.rotateUp(Math.PI / 4);
		controls.target.set(
			camera.position.x + 0.1,
			camera.position.y,
			camera.position.z
		);
		controls.noZoom = true;
		controls.noPan = true;

		function setOrientationControls(e) {
			if (!e.alpha) {
				return;
			}

			controls = new THREE.DeviceOrientationControls(camera, true);
			controls.connect();
			controls.update();

			element.addEventListener('click', fullscreen, false);

			window.removeEventListener('deviceorientation', setOrientationControls, true);
		}
		window.addEventListener('deviceorientation', setOrientationControls, true);


		var light = new THREE.HemisphereLight(0x777777, 0x000000, 0.6);
		scene.add(light);

		var texture = THREE.ImageUtils.loadTexture(
			'textures/patterns/checker.png'
		);
		texture.wrapS = THREE.RepeatWrapping;
		texture.wrapT = THREE.RepeatWrapping;
		texture.repeat = new THREE.Vector2(50, 50);
		texture.anisotropy = renderer.getMaxAnisotropy();

		var material = new THREE.MeshPhongMaterial({
			color: 0xffffff,
			specular: 0xffffff,
			shininess: 20,
			shading: THREE.FlatShading,
			map: texture
		});
		material.side = THREE.DoubleSide;
		var geometry = new THREE.PlaneGeometry(1000, 1000);
		var mesh = new THREE.Mesh(geometry, material);
		mesh.rotation.x = -Math.PI / 2;
		scene.add(mesh); https://threejs.org/examples/webgl_buffergeometry_lines_indexed.html
		window.addEventListener('resize', resize, false);
		setTimeout(resize, 1);
		////rectangle in center fo room

		var texture = new THREE.TextureLoader().load('textures/patterns/checker.png');
		var geometry = new THREE.BoxGeometry(27, 27, 27);
		var material = new THREE.MeshBasicMaterial({ map: texture });
		mesh = new THREE.Mesh(geometry, material);
		scene.add(mesh);





		////////////////load menu images
		for (var i = 0; i < levels.length; i++) {
			loadpic(levels[i]);
		}

		////load the people avatars
		for (var i = 0; i < 6; i++) {
			addspheres(i);

		}

	}


	function resize() {
		var width = container.offsetWidth;
		var height = container.offsetHeight;

		camera.aspect = width / height;
		camera.updateProjectionMatrix();

		renderer.setSize(width, height);
		effect.setSize(width, height);
	}




	function loadpic(file) {
		texture = THREE.ImageUtils.loadTexture(
			'images/' + file + '.png'
		);
		material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, color: '#FFFFFF' }),
		// material = new THREE.MeshPhongMaterial({color: 0xCC0000});
		geometry = new THREE.PlaneGeometry(50, 50),
		mesh = new THREE.Mesh(geometry, material),
		mesh.rotation.x = 270 * Math.PI / 180,
		mesh.position.x = 100;
		mesh.position.z = addto;
		mesh.position.y = 10;
		mesh.rotation.y = -1.57;
		scene.add(mesh);
		addto = addto + 50;
	}


	function addspheres(num) {
		obid = num;
		num = new THREE.Mesh(new THREE.CylinderGeometry(1, 3, 40, 100, 100, false), new THREE.MeshBasicMaterial({ color: '#0000ff' }));
		num.name = "mesh" + obid;
		num.position.z = 6000;

		scene.add(num);
	}

	///variables to identify my position info

	var isme = [0, 0];
	var ismaybe = [];
	var newdist = 0;
	var mydist = 6000;


	function distanceBetweenPoints(p1, p2) {
		newdist = Math.abs(Math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1])));
		return newdist
	}

	function update(dt) {
		resize();
		camera.updateProjectionMatrix();
		controls.update(dt);


		ws.onmessage = function (event) {
			//if (res = "begin") {
			//set my position based on direction facing and pos in room

			//} else {

			res = event.data.split("e");
			mydist = 800;
			for (p = 0; p < res.length; p++) {
				xpos = res[p].split("y");
				ismaybe[0] = xpos[2];
				ismaybe[1] = xpos[1];

				if (mydist > distanceBetweenPoints(isme, ismaybe)) {
					isme[0] = xpos[2];
					isme[1] = xpos[1];
					//camera.position.set(xpos[2],5,xpos[1]);
					//alert("yes!");
					mydist = newdist;
				}

				//camera.position.x = -isme[0]/10  ;
				//camera.position.z = isme[1]/10  ;

				name = "mesh" + p;
				var object = scene.getObjectByName(name);

				//alert(object);
				object.position.z = xpos[1] / 10;
				object.position.x = -xpos[2] / 10;
				//camera.position.z = xpos[1]/10 ;
				//camera.position.x = -xpos[2]/10 ;

				//
				//object.position.z = 1;
				//object.position.x = 1;
				//var object2 = scene.getObjectByName("mesh1");
				//}

			}
			//console.log(isme)
			camera.position.set(-isme[0] / 10, 20, isme[1] / 10);


		}

	}

	function render(dt) {
		effect.render(scene, camera);
	}

	function animate(t) {
		requestAnimationFrame(animate);

		update(clock.getDelta());
		render(clock.getDelta());
	}

	function fullscreen() {
		if (container.requestFullscreen) {
			container.requestFullscreen();
		} else if (container.msRequestFullscreen) {
			container.msRequestFullscreen();
		} else if (container.mozRequestFullScreen) {
			container.mozRequestFullScreen();
		} else if (container.webkitRequestFullscreen) {
			container.webkitRequestFullscreen();
		}
	}
</script>

</body>

</html>